## 简历内容



### 网络模块

实现代码如下

```java
// Retrofit配置
private void initHttp(BaseApplication application) {
    retrofit = new Retrofit.Builder()
        .client(getClient(application.getApplicationContext()))
        .baseUrl(application.getAppHost())
        .addConverterFactory(GsonConverterFactory.create(getGson()))
        .addCallAdapterFactory(new RxMainThreadCallAdapterFactory())
        .addCallAdapterFactory(RxJava2CallAdapterFactory.createWithScheduler(Schedulers.io()))
        .build();
}

/**
* 改成第一次调用时初始化
*/
public static Retrofit getRetrofit() {
    if (retrofit == null){
        NetworkManagerHolder.sManager.initHttp(BaseApplication.getInstance());
    }
    return retrofit;
}

public static void clear() {
    retrofit = null;
}

//工具类使用单例，保证Retrofit实例全局只有一个，不会重复创建
private static class NetworkManagerHolder {
    private static NetworkManager sManager = new NetworkManager();
}

// OkHttpClient初始化配置
private OkHttpClient getClient(Context applicationContext) {
    return new OkHttpClient.Builder()
        //token过期处理
        .addInterceptor(new BaseUrlInterceptor())
        //统一请求头配置
        .addInterceptor(new HeaderInterceptor())
        //全局日志拦截器
        .addInterceptor(new LoggingInterceptor.Builder()
                        .tag(BaseApplication.LOG_NETWORK_TAG)
                        .loggable(ConstansKTKt.isDev() || ConstansKTKt.isDebug())
                        .setLevel(Level.BASIC)
                        .build()
                       )
        .addInterceptor(new TrackerInterceptor())
        .connectTimeout(TIMEOUT_CONNECTION, TimeUnit.SECONDS)
        .readTimeout(TIMEOUT_READ, TimeUnit.SECONDS)
        .writeTimeout(TIMEOUT_WRITE, TimeUnit.SECONDS)
        //失败重连
        .retryOnConnectionFailure(true)
        //创建缓存文件
        .cache(new Cache(new File(BaseApplication.getInstance().getCacheDir().getAbsolutePath() + "/" + CACHE_DIR_NAME), CACHE_SIZE_BYTES))
        .build();
}

//网络接口配置类，只需要写接口名称，入参，出参就可以完成网络请求
public interface ApiService {
    /**
     * 获取附近学校列表
     */
    @GET("campus/mongo/nearMongoCampus")
    Observable<BaseResponse<List<SchoolBean>>> getNearbySchoolList(
        @Query("latitude") String longitude, 
        @Query("longitude") String latitude);

    /**
     * 获取学校列表
     */
    @GET("school/listSchoolApp")
    Observable<BaseResponse<CommonDataListBean<SchoolBean>>> getOnlySchoolList(
            @Query("page") int pages,
            @Query("pageSize") int pageSize,
            @Query("keyWord") String keyWord);
    
}
```

具体如何发起一次网络请求，代码如下

```java
NetworkManager.getRetrofit().create(ApiService.class)
    .getNearbySchoolList(latitude, longitude)
    .compose(RxHelper.applySchedulers())
    .subscribe(new BaseObserver<List<SchoolBean>>(mRxManager) {
        @Override
        protected void onSuccess(List<SchoolBean> list) {
            
        }
    });
```



### 性能架构优化

内存泄漏常见问题九条进行代码检查

1. 资源性对象未关闭

   对于资源对象不再使用时，应该立即调用它的close()函数，将其关闭并设置为null。例如Bitmap等资源未关闭会造成内存泄漏，应该在Activity销毁时及时关闭。

2. 注册对象未注销

   例如BroadcastReceiver，EventBus未注销造成内存泄漏，应该在Activity销毁时及时注销。

3. 类的静态变量持有大数据对象

   尽量避免使用静态变量存储数据，特别是大数据对象，建议使用数据库存储。

4. 单例造成的内存泄漏

   优先使用Application的Context，如需要使用Activity的Context，可以在传入Context时使用弱引用进行封装调用。

5. 非静态内部类的静态实例

   静态实例的生命周期和应用一样长，导致静态实例一直持有Activity引用，Activity内存资源不能正常回收。应该抽取出来封装成一个单例使用。

   ````java
   //context由于是静态变量会持有MyActivity的引用，但是静态变量的生命周期和应用一样长
   //当MyActivity需要回收时，由于context持有引用，会导致MyActivity无法被回收
   public class MyActivity extends AppCompatActivity {
       private static Context context;
   
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_my);
   
           context = this;
       }
   }
   ````

6. Handler临时性内存泄漏

   java中非静态内部类会持有外部类的引用，那么handler会持有Activity的引用，handler发送Message之后会存储在`MessageQueue`中，`MessageQueue`的生命周期和应用一样长，如果当Activity销毁时这个handler还没有执行完成，那么`MessageQueue`中存储的`Message`还在， 而`Message`中的`target`会持有handler的引用，handler又会持有Activity的对象，那么导致Activity无法被回收。

   将handler变成静态内部类，但静态内部类是不能调用Activity内部非静态变量，故可以加上弱引用持有外部Activity来实现。

   ````java
   // 设置为：静态内部类
   private static class FHandler extends Handler{
       // 定义 弱引用实例
       private WeakReference<Activity> reference;
   
       // 在构造方法中传入需持有的Activity实例
       public FHandler(Activity activity) {
           // 使用WeakReference弱引用持有Activity实例
           reference = new WeakReference<Activity>(activity); 
       }
   }
   ````

7. 容器中的对象没清理造成内存泄漏

   在退出程序之前，将集合里的东西clear并设置为null

8. 使用ListView时造成的内存泄漏

   在构造Adapter时使用缓存convertView

9. 图片加载如果使用不当会引起内存OOM



**`ConstraintLayout`布局简单介绍**

**如何使用**

添加依赖就能引入`androidx.constraintlayout:constraintlayout:2.0.2`

整体上看`ConstraintLayout`和`RelativeLayout`很像，但是加入比`RelativeLayout`更加多的功能，而且还单独设计了一个可以用于拖动布局的开发工具。

`ConstraintLayout`布局也和`RelativeLayout`都要写相对于其他控件或屏幕，最大的好处是可以减少布局层次嵌套。

常用的相对定位属性：
`layout_constraintTop_toTopOf`
`layout_constraintTop_toBottomOf`
`layout_constraintBottom_toTopOf`
`layout_constraintBottom_toBottomOf`
`layout_constraintBaseline_toBaselineOf`
`layout_constraintStart_toEndOf`
`layout_constraintStart_toStartOf`
`layout_constraintEnd_toStartOf`
`layout_constraintEnd_toEndOf`



**Chains链**

Chains链可以简单的理解为在同一级（垂直或者水平）条件下，相近的View有相互约束的存在，便构成了Chains链结构，位于最左侧或者最上侧的View被称为链头，想要实现特殊样式，只需要更改链头的chainStyle属性即可，且只有链头的chainStyle属性更改会生效，其他View的chainStyle属性设置了也不会起作用。

链头有三种属性

* spread
* spread_inside
* packed
* weighted. 使用`layout_constraintHorizontal_weight`属性，控件的`layout_width`要设置成0才有用，和`LinearLayout`的`weight`属性类似效果

三种不同属性的布局效果如图

![](C:\DevelopProject\learn\note\images\约束布局-chains.png)

`Bias`属性。**简单的讲，链头左边的距离占剩余未利用的空间的比例。**设置为0.2意思就是链头左边空余空间占据总剩余未利用空间的1/5。



比较有用的单属性：

* `goneMargin`。当两个控件左右排列，TextView2在TextView1的右边，当TextView1设置为gone时，TextView2应该是左移到TextView1的位置，但是如果TextView2设置了`goneMargin`设置，这时TextView2会有一个距离左边距离，大小为`goneMargin`设置的大小。
* `layout_constraintDimensionRatio`宽高比。可以设置控件的宽高比，`width`和`height`都要设置为0dp，布局会根据不同屏幕页面大小进行适配。该属性在页面有明显不同大小图片分块时非常好用。
* 一行文字后面跟图标，并且文字超过一行需要省略。
  * 正常解决是重写一个布局，实时计算文字超长时要预留图片空间，或者通过计算文字显示控件宽度截取刚好的文字
  * 使用`ConstraintLayout`只需要`layout_height="wrap_content"`和`layout_constrainedWidth="true"`属性就可以实现，再增加`layout_constraintHorizontal_bias="0"`和`layout_constraintHorizontal_chainStyle="packed"`保证所有控件是居左排序的
* `space`。只是单纯的一个点位view，主要效果是边距补偿。当两个view有相互叠加的效果，`ContraintLayout`里面margin是不能为负数，可以使用space。



**APP大小瘦身**

可以使用android studio工具直接打开应用apk包，解压包后会分析出每个目录的占用空间大小，一般占用空间比较大的目录为

* 排查res目录
  * drawable目录下主要存放图片，图片最好使用压缩过的png或使用压缩过的webp
  * raw目录下主要存放一些音，视频文件，最好使用在线文件或进行压缩
* 排序lib目录
  * 一般会放一些第三方包，看是否能够删除
  * 如果使用flutter混合开发，在gradle里面ndk配置只需要 'arm64-v8a'和'armeabli-v7a'，删除多余配置

图片大小优化

通过如下几种方式

*  tinypng压缩png 压缩率大概在70-80%，大图压缩过质量损失明显

* 直接png转换成webp格式，压缩率稳定性不稳定，简单图片压缩率高，高清图转换后甚至比png占用空间更加多

* android studio -> convert to webp有损压缩转换webp，压缩率能达到90%，还可以手动控制图片质量，比较灵活

**压缩webp配置**

一般图标或者背景图片压缩率设置成75%，基本看不出图片质量损失

全屏大图和大图压缩率设置成90%，基本看不出图片质量损失

原来APP图片drawable图片文件大小32m，优化之后大小16m



**APP启动速度**

APP运行时帧率，如何查看，如何优化

* 打开手机“设置”→“开发者选项”。找到监控一栏点击“GPU更显模式分析”→勾选上“dab shell dumpsys gfxinfo”

* 查看APP全包名，输入`adb shell "dumpsys window|grep mCurrentFocus"`指令，从返回结果`mCurrentFocus=Window{7fcad03 u0 com.mandofin.md51schoollife/com.mandofin.md51schoollife.modules.MainActivity}`得到APP全名

* 打开被测试APP进行需要测试页面的滑动和切换，输入`adb shell dumpsys gfxinfo com.mandofin.md51schoollife > FPS.txt`，会在本地电脑上`C:\Users\SK`下生成一个FPS.txt

* 在FPS.txt中有一行Profile data in ms:包含了APP运行时的帧率

  * Draw:   表示在Java中创建显示列表部分中，OnDraw()方法占用的时间。
  * Process：表示渲染引擎执行显示列表所花的时间，view越多，时间就越长。
  * Execute：表示把一帧数据发送到屏幕上排版显示实际花费的时间。

  Draw + Process + Execute = 完整显示一帧 ，这个时间要小于16ms才能保证每秒60帧。

  

应用冷启动时间，如何查看，如何优化 

应用启动状态：

* 冷启动。是指应用从头开始启动：系统进程在冷启动后才创建应用进程。发生冷启动的情况包括应用设备启动后或系统终止应用后首次启动。
* 热启动。指应用所有Activity都驻留内存中，系统的所有工作只是将Activity带到前台。一般home按键快速切换应用



启动时间统计指令： adb shell am start -S -W  [packageName]/.[activityName]

命令行启动应用后会出现三个时间

ThisTime：表示一连串启动Activity的最后一个Activity启动的耗时

TotalTime：表示新应用启动的耗时，包括新进程的启动和Activity的启动，但不包括前一个应用的pause的耗时

WaitTime：包括前一个应用Activity pause的时间和新应用启动的时间

一般用TotalTime来查看应用冷启动耗时，一般比较理想的是1s左右。



应用中页面跳转时启动页面所需要时间，一般在logcat中会有输出，不同机型输出日志不同

* 小米，三星，Vivo：ActivityManager: Displayed，一般格式为`ActivityManager: Displayed [packageName]/.[activityName]: +562ms`
* 华为：ScreenCommon



**fragment懒加载，页面部分控件延迟加载，部分控件在子线程初始化**

需要进行优先级排序

最高级：首页展示第一屏内容，日志初始化，网络请求

需要使用但可以进行一定延迟加载：首页浮动广告，非第一屏tab内容，

非应用启动相关：自定义view布局，初始化（推送，图片选择框架，应用更新，本地日志上传）



**项目架构，代码**

代码规范

* kotlin语法，尽量不出现!!，减少空指针出现情况
* 列表容器尽量使用ArrayMap和SparseArray代替ArrayList和HashMap，性能更加好
* 同一模块内部不使用ARouter跳转activity，尽量减少eventbus使用
* 中文字符放在string.xml中
* 不同模块的资源文件前面加模块前缀，防止相互引用导致错乱
* 常量增加统一前缀保持代码可读性，或者使用统一Constant类来管理不同类别
  * SharedPreferences  前缀 PREF_
  * Bundle  前缀  BUNDLE_
  * intent  前缀  EXTRA_



### 图片加载优化

阿里云加载图片api，在图片url后面拼接参数就可以完成图片大小调整，实现如下

`"x-oss-process=image/resize,w_600,m_lfit"`，w_600 代表图片宽度为600，h_lfit 代表图片高度自适应



Glide实现ModuleLoader，实现`BaseGlideUrlLoader`

````kotlin
class CustomGlideUrlLoader(concreteLoader: ModelLoader<GlideUrl, InputStream>, modelCache: ModelCache<GlideUrlBean, GlideUrl>) : BaseGlideUrlLoader<GlideUrlBean>(concreteLoader, modelCache) {

    private val OSS_IMAGE_PRE = "x-oss-process=image"

    override fun getUrl(model: GlideUrlBean?, width: Int, height: Int, options: Options?): String? {
        if(model == null) return null
        if(model.isResized) {
            return model?.originUrl
        }
        if(model?.originUrl.startsWith("http") && model?.originUrl.contains("caochangjihe.com")) {
            val resizeUrl = getResizeUrl(width, model.originUrl)
            return resizeUrl
        } else {
            model.isResized = true
            return null
        }
    }

    private fun getResizeUrl(width: Int, originUrl: String): String? {
        val bestFitWidth = getBestFitWidth(width)
        if (width <= 0) {
            return originUrl
        }
        val resizeUrl = StringBuilder()
        resizeUrl.append(originUrl)
        if (originUrl.contains(OSS_IMAGE_PRE)) { //已经有处理图片的操作
            if (!originUrl.contains("resize")) {
                resizeUrl.append("/resize,w_$bestFitWidth,m_lfit")
                return resizeUrl.toString()
            } else {
                return resizeUrl.toString()
            }
        } else { //没有图片的操作
            val uri = Uri.parse(originUrl)
            val zpParams = uri.encodedQuery
            if (TextUtils.isEmpty(zpParams)) {
                resizeUrl.append("?")
            }
            resizeUrl.append("x-oss-process=image/resize,w_$bestFitWidth,m_lfit")
            return resizeUrl.toString()
        }
    }

    private fun getBestFitWidth(width: Int): Int {
        if(width <= 0) {
            return width
        }
        if(width < 200) {
            return 200
        }
        if(width < 400) {
            return 400
        }
        if(width < 800) {
            return 800
        }
        if(width < 1000) {
            return 1000
        }
        if(width < 1600) {
            return 1600
        }
        if(width < 2000) {
            return 2000
        }
        if(width < 4000) {
            return 4000
        }
        return -1
    }

    override fun handles(model: GlideUrlBean): Boolean {
        return true
    }

    /**
     * ModelLoaderFactory来构建CustomGlideUrlLoader对象
     */
    class Factory : ModelLoaderFactory<GlideUrlBean, InputStream> {
        private val urlCache: ModelCache<GlideUrlBean, GlideUrl> = ModelCache(150)
        override fun build(multiFactory: MultiModelLoaderFactory): ModelLoader<GlideUrlBean, InputStream> {
            return CustomGlideUrlLoader(multiFactory.build(GlideUrl::class.java, InputStream::class.java), urlCache)
        }

        override fun teardown() {}
    }
}
````

自定义GlideModule

```kotlin
//注解可以不用注册
@GlideModule
class CustomGlideModule : AppGlideModule() {
	//可以根据实际情况对加载图片配置进行修改
    override fun applyOptions(context: Context, builder: GlideBuilder) {
        super.applyOptions(context, builder)
    }
	//表示是否需要在清单文件里进行注册，使用注解就不需要注册
    override fun isManifestParsingEnabled(): Boolean {
        return false
    }
	
    override fun registerComponents(context: Context, glide: Glide, registry: Registry) {
        super.registerComponents(context, glide, registry)
        registry.append(GlideUrlBean::class.java, InputStream::class.java, CustomGlideUrlLoader.Factory())
    }
}
```



可以在Application的`OnTrimMemory`方法里同调用Glide.clearMemory()来清除缓存，来进行释放内存。
`OnTrimMemory `回调是 Android 4.0 之后提供的一个API，这个 API 是提供给开发者的，它的主要作用是提示开发者在系统内存不足的时候，通过处理部分资源来释放内存，从而避免被 Android 系统杀死。这样应用在下一次启动的时候，速度就会比较快。

`OnTrimMemory `返回int类型的参数有如下几个意义

* `TRIM_MEMORY_UI_HIDDEN`表示应用程序所有UI界面被隐藏了，一般是用户点击了Home键或点击Back键返回手机桌面

当应用程序正在运行进返回参数

* `TRIM_MEMORY_RUNNING_MODERATE `表示应用程序正常运行，并不会被杀掉。但当前手机内存有点低了，系统有可能会根据LRU缓存规则去杀死一些进程
* `TRIM_MEMORY_RUNNING_LOW`表示应用程序正常运行，并不会被杀掉。但当前手机内存已经非常低了，应该去释放掉一些资源。
* `TRIM_MEMORY_RUNNING_CRITICAL `表示应用程序正常运行，但系统已经根据LRU缓存规则杀掉大部分缓存进程。这个时候应该释放掉所有不必要的资源。

当应用在后台缓存时返回参数

* `TRIM_MEMORY_BACKGROUND `表示手机目前内存已经很低了，系统开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。
* `TRIM_MEMORY_MODERATE`表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。
* `TRIM_MEMORY_COMPLETE`表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。

根据上面返回参数的描述，可以制定如下规则

* 当前为`TRIM_MEMORY_BACKGROUND`时去释放所有内存缓存，这样保证我们应用始终在LRU缓存列表的最近位置，这样应用就不太会被后台清理掉。

* 当前为`TRIM_MEMORY_UI_HIDDEN`和`TRIM_MEMORY_RUNNING_CRITICAL`时去释放内存缓存的一半，因为当前状态下我们的应用是不太可能会被杀掉的，但是为了保证应用的流程度，还需要释放一部分缓存。



**`OnTrimMemory`和`OnLowMemory`的关系？**
在引入`OnTrimMemory`之前都是使用`OnLowMemory`回调，需要知道的是，`OnLowMemory`大概和`OnTrimMemory`中的`TRIM_MEMORY_COMPLETE`级别相同，如果你想兼容api<14的机器，那么可以用`OnLowMemory`来实现，否则你可以忽略`OnLowMemory`，直接使用`OnTrimMemory`即可。



### 长图加载

实现长图加载主要步骤如下

* 初始化。注册滑动手势`GestureDetector`，通过`setOnTouchListener`的`onTouch`事件将触摸手势交给`GestureDetector`处理，注册`Scroller`用于辅助滑动事件
* 设置图片。使用`BitmapFactory.Options.inJustDecodeBounds = true`属性，通过`BitmapFactory.decodeStream`获取图片长/宽，初始化`BitmapRegionDecoder`类
* `onMeasure()`。获取视图宽高，通过视图宽度和图片宽度的比例来进行图片压缩，得到展示图片区域的矩形坐标
* `onDraw()`。根据`mBitmapRegionDecoder.decodeRegion(mRect, mOptions)`得到显示区域部分的bitmap，使用`canvas.drawBitmap`绘制图片并传入`matrix`进行缩放转换
* `onScroll()`。通过`mRect.offset(0, (int) distanceY)`来根据滑动改变加载图片区域，判断滑动到最底部和最顶部不能越界
* `computeScroll`。判断滚动是否结束，如果没有结束获取`scroller.getCurrY()`来更新图片显示区域
* `onFling`。使用`scroller.fling`处理页面快速滑动事件



### kotlin与java对比

[对比链接]: https://mp.weixin.qq.com/s/FqXLNz5p9M-5vcMUkxJyFQ

[对比链接](https://mp.weixin.qq.com/s/FqXLNz5p9M-5vcMUkxJyFQ)



### Flutter与android原生交互





### uni-app

