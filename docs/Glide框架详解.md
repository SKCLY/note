# Glide框架详解

[链接]: https://blog.csdn.net/sinyu890807/category_9268670.html



#### Glide有几级缓存？

主要分成两个大的模块，一个内存缓存，一个硬盘缓存。

* 活动缓存：弱引用集合存储正在使用的图片，存储在内存中，比如正在展示的图片，或者列表中不在当前页面展示的图片。

* 内存缓存（LruCache）：存储最近被加载过的图片，存储在内存中，与活动缓存互斥，使用的是LRU机制

* 磁盘缓存-资源类型（持久化缓存，DiskLruCache）：存储被转换，解码后的图片，例如缩放过大小，圆角处理

* 磁盘缓存-数据来源（持久化缓存）：网络请求成功后原图存储到文件当中

  

**对于活动缓存和内存缓存互斥条件？**

对每张图片都有一个计数变量，每加载一次图片就会+1，每次release都会-1，如果值为0说明当前没有使用图片就会回收到第二层内存缓存中，如果大于0就会放入活动缓存中。

**为什么要设计两种内存缓存？**

**`LruCache`内部实现机制**：使用的是`LruCache`，内部是用一个`Set`来缓存对象的，每次内存超出时触发`trimToSize`操作，会对`Set`进行遍历并移除缓存，这有可能把正在使用的缓存给删除了。

例子：比如`Lru`缓存设置能缓存99张图片，当列表滑动到第100张图片时，那么就会回收掉已经加载的第一张图片，这样当滑动到第一张的时候需要重新去请求图片，这样显然没有充分利用资源。

所以增加了一个活动缓存来存储正在使用的图片，这样解决了二个问题：

* 加载正在使用中的图片效率问题。
  * 原来需要重新加载，现在直接从活动缓存中读取，效率更加高
  * `LruCache`是用LinkedHashMap存储数据，活动缓存优化为HashMap，提升读取效率
  * `TrimToSize()`需要遍历链表，速度比较慢。增加了活动缓存分担`LruCache`压力，减少`TrimToSize`的概率，提升加载速度

* 本质是用空间换时间的策略。 所以活动缓存使用弱引用来存储图片，当系统内存不够时会释放内存，不用担心占用太多的内存导致OOM



#### Glide如何绑定生命周期？

Glide初始化的时候创建一个完全没有内容的fragment，在fragment里使用LifecycleCallback绑定生命周期，这样在Activity生命周期结束时就可以回收资源，从而不需要在Activity里面再去手动写回收资源代码。



#### Glide的BitmapPool如何实现复用

