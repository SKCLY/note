# 面试题汇总

#### raw文件夹和assets文件夹有什么区别

raw：andorid会自动为这个目录中所有资源文件生成一个ID，意味着很容易就可以访问到这个资源，在可以在xml中使用，使用id访问速度很很快。

assets：不会生成ID，只能通过AssetManager访问，不能在xml中使用，访问速度很慢些，不过操作更加方便。



#### 什么是依赖注入，能说说几个依赖注入的库？(Dagger2)

##### 什么是依赖？

依赖是类与类之间的连接，依赖关系表示一个类依赖另一个类的定义。



依赖注入就是类不自己去实例化依赖，注射器去创建，然后在合适的时候注入进来，实现依赖实例化。

实现依赖注入的方式有3种

1. 构造函数中注入
2. setter方法注入
3. 接口注入

````java
public interface DepedencySetter {
	void setDriveable(Driveable driveable);
}
public class Person implements DepedencySetter {
    private Driveable mDriveable;
    
    //构造函数注入
    public Person2(Driveable driveable) { this.mDriveable = mDriveable; }

    //setter 方式注入
    public void setDriveable(Driveable mDriveable) { this.mDriveable = mDriveable; }
    
    //接口方式注入
    @Override
    public void setDriveable(Driveable driveable) { this.mDriveable = mDriveable; }
}
````



#### synchronized关键字作用是什么？

synchronized可以在多线程环境下用来作为线程安全的同步锁

主要有以下三种用法

* 修饰代码块 
* 修饰成员方法  修饰为this
* 修饰静态方法  修饰为类的Class对象



#### 如何使用反射获取T的真实类型

````java
public class HttpCallBack<T> {
    
    //好处：可以封装类型转换过程，简化业务端代码操作
    pulic void onSuccess(String result) {
        Gson gson = new Gson();
        //传入this得到不同用户传入不同数据类型T的字节码
        Class<?> clz = analysisClassInfo(this);
        //根据gson就可以转换得到最后业务类
        T objT = (T)gson.fromJson(result, clz);
        //返回业务结果
        onSuccess(objT);
    }
	
    private CLass<?> analysisClassInfo(Object obj) {
        //getGenericSuperclass得到包含原始类型，参数化，数组，类型变量，基本数据
        Type getType = obj.getClass().getGenericSuperclass();
        // 获取参数化类型
        Type[] params = ((ParamterizedType)getType).getActualTypeArguments();
        return (Class<?>)params[0];
    }
}
````



### 注解

#### 注解的定义

Java 注解用于为 Java 代码提供元数据。注解相当于标签

#### 如何自定义注解

注解通过@interface关键字进行定义，形式和接口类型，不过interface前面多了一个@

````java
public @interface Test{}
````

使用注解

````java
@Test
public class TestAnnotation {}
````

#### 元注解 

元注解是可以在注解上使用的注解，是一种基本注解，能够应用到其他注解上面。它的作用和目的就是给其他普通注解进行解释说明。

元注解有5种 @Retention，@Ducmented，@Target，@Inherited，@Repeatable

* @Retention

  Retention意为保留期，作用是标注了一个注解的存活时间

  取值如下：

  1. RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。最常用的注解@Override，主要用于代码编写时检查代码格式问题。

       		2. RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM中。比较常见第三方框架中使用，ButterKnife中的@BindeView，@OnClick等，主要用于编译期通过注解生成一些辅助类，减少一些重复，固定代码操作。
                     		3. RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM中，所以在程序运行时可以获取到它们。比较常见于第三方框架，Retrofit中的@POST，@GET等网络请求注解，用于在运行期通过反射获取注解的请求。

* @Target

  Target是目标的意思，指定注解运用的地方

  取值如下：

  1. ElementType.ANNOTATION_TYPE可以给一个注解进行注解

   	2. ElementType.CONSTRUCTOR 可以给构造方法进行注解
   	3. ElementType.FIELD 可以给属性进行注解
   	4. ElementType.LOCAL_VARIABLE 可以给局部变量进行注解
   	5. ElementType.METHOD 可以给方法进行注解
   	6. ElementType.PACKAGE 可以给一个包进行注解
   	7. ElementType.PARAMETER 可以给一个方法内的参数进行注解

* @Documented

  它的作用是能够将注解中的元素包含到 Javadoc 中去

* @Inherited

  Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。

* @Repeatable

  Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。

  什么样的注解会多次应用呢？通常是注解的值可以同时取多个。

#### 注解的属性

注解的属性也叫做成员变量。注解只有成员变量，没有方法。 需要注意的是，在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组注解中属性可以有默认值，默认值需要用 default 关键值指定。

````java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test{
	int id() default -1;
	String msg() default "Hello";
}
````

#### 注解的提取

注解一般通过反射获取。

首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解。

```` java
public boolean isAnnotationPresent(Class<?> extends Annotation annotationClass) {}
````

然后通过 getAnnotation() 方法来获取 Annotation 对象或者是 getAnnotations() 方法。

````java
public <A extends Annotation> A getAnnotation(Class<A> annotationClass) {}
public Annotation[] getAnnotations() {}
````

#### 注解的使用场景

* 提供信息给编译器： 编译器可以利用注解来探测错误和警告信息，如@Override
* 编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、 Html文档或者做其它相应处理。如ButterKnife的@BindeView，@OnClick等
* 运行时的处理： 某些注解可以在程序运行的时候接受代码的提取，值得注意的是，注解不是代码本身的一部分。如Retrofit的@POST，@GET等



#### Bundle用来传递数据，为什么不用HashMap代替？

1. Bundle传递数据是用intent，intent最大传输的数据量是1M，故Bundle设计就是用于小数据量传输。HashMap内部则是数组+链表结构，在数据量比较小的时候，HashMap的Entry Array比ArrayMap(Bundle内部实现)占用更多的内存。
2. 使用intent携带数据是需要对数据序列化，Bundle使用Parcelable序列化，而HashMap则是Serializable序列化，相比Bundle效率更高。



#### 谈谈Serializable和Parcelable接口的区别 

* Serializable是java自带的序列化接口。
  * 具体实现：序列化时会把serialVersionUID写入序列化文件中，数据是以二进制数据流存储，反序列化时会去检测文件中serialVersionUID与当前类中是否一致，如果不一致则说明当前类已经发生改变，不能正常反序列化(如成员变量数量和类型变化)
  * 优点：1.使用方便。只需要实现Serializable接口并声明一个serialVersionUID就可以实现序列化。  2.序列化之后占用空间相对小
  * 缺点：序列化过程中会产生大量临时变量，会有大量IO操作，引起频繁GC操作
  * 使用场景：数据持久化存储
* Parcelable是Android新增的序列化接口。
  * 具体实现：调用writeToParcel方法通过Parcel中的一系列write方法实现序列化。由CREATOR完成反序列化，内部通过createFromParcel方法来创建序列化对象并通过newArray方法创建数组，最终通过Parcel的一系列read方法完成。(write的顺序必需和read的顺序相同)。
  * 优点：1. 在内存使用时性能比较高。  2.可以将一个完整的对象进行分解，分解后每一部分都可以进行intent传输。
  * 缺点：1.使用起来相对复杂。  2.序列化对象占用空间比较大。  3.反序列化更加严格，会因为对象的成员变量增加导致反序列化失败。
  * 使用场景：内存中使用，使用intent传递数据



#### 解释一下Intent显示和隐式？

显示Intent是明确目标Activity的类名时调用，主要如下三种方式

* 通过Intent(Context packageContext, Class<?> cls)构造方法

  ````java
  Intent intent = new Intent(this, SecondActivity.class);
  startActivity(intent);
  ````

* 通过Intent的setComponent()方法

  ````java
  ComponentName componentName = new ComponentName(this, SecondActivity.class);
  ComponentName componentName = new ComponentName(this, "com.sk.SecondActivity");
  ComponentName componentName = new ComponentName(getPackageName(), "com.sk.SecondActivity");
  
  Intent intent = new Intent();
  intent.setComponent(componentName);
  startActivity(intent);
  ````

* 通过Intent的setClass/setClassName方法。其内部是调用setComponent()方法实现

  ````java
  Intent intent = new Intent();
  intent.setClass(this, SecondActivity.class);
  intent.setClassName(this, "com.sk.SecondActivity");
  intent.setClassName(getPackageName(), "com.sk.SecondActivity");
  startActivity(intent);
  ````

隐式Intent通过设置Action，Data，Category，让系统筛选过符合的Activity。

可以通过隐式调用外部APP的页面，如Intent.ACTION_DIAL

````java
<intent-filter>
    <action android:name="com.sk.second" />
    <category android:name="android.intent.category.DEFAULT" />
</intent-filter>
        
Intent intent = new Intent("com.sk.second");
startActivity(intent);
````

**显示Intent更适合在同项目下使用，隐式Intent更适合不同项目间的页面跳转。**



#### 什么是support library?

主要是因为安卓版本更新太快，新版本会推出很多新的功能，为了保证向后兼容，使得低版本的APP能在高版本的手机上正常运行，这个就是support library的作用。



#### 什么是ANR？什么情况造成ANR？

ANR(Application Not Responding)，是指应用程序未响应，当处理一些事件超过预定时间未能得到响应就会造成ANR

报错场景：

* 对于前台服务，超时时间SERVICE_TIMEOUT 20S
* 对于后台服务，超时时间SERVICE_BACKGROUND_TIMEOUT 200S
* 对于前台广播，超时时间BROADCAST_FG_TIMEOUT 10S
* 对于后台广播，超时时间BROADCAST_BG_TIMEOUT 60S
* ContentProvider超时时间CONTENT_PROVIDER_PUBLISH_TIMEOUT 10S
* 输入事件超时时间 5S

ANR分析：

	1. 开发调试阶段可以通过android studio错误日志排查
 	2. 收集各个线程调用栈trace信息，traces信息和CPU使用信息都会保存在data/system/dropbox/app文件类似data_app_anr文件中
     * 定位ANR发生时间点
     * 线程名称，线程状态，引起ANR的页面

如何避免ANR发生：

​	1. 主线程尽量只做UI相关的操作，避免耗时操作。如复杂UI绘制，网络操作，文件IO操作

​	2. 避免主线程跟工作线程发生锁的竞争。要注意sharePreference操作，在主线程可以使用apply代替commit操作。



#### Dalvik和ART的区别？

Dalvik

1. Dalvik环境中应用每次运行时，字节码都需要通过即时编译器(Just In Time, JIT)转换为机器码。故应用运行会比较慢。

ART(Android4.4引入)

1. ART环境中，应用会在安装时将字节码预编译(Ahead Of Time, AOT)成机器码，故应用运行速度很快，但是安装速度会变慢，占用的空间也会大10%。
2. ART不用每次运行时都重复编译，减少CPU使用频率，降低了能耗。

android 7.0后优化

​	混合使用AOT和JIT，在安装时不进行AOT(提升安装速度)，运行过程中对经常执行的方法进行JIT，并记录到Profile配置文件中。当设置空闲和充电时，编译进程根据Profile文件对常用代码进行AOT编译，故APP会随着使用时间变长速度越快。



